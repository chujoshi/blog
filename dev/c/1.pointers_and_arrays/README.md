# 포인터와 배열의 차이

포인터와 배열은 모두 c언어에서 지원하는 자료형이다.   
예시를 보면서 설명을 이어나가겠다.

예시 코드
```c
char a[] = "where is johntonde";
char *c = a;

printf("a의 길이 : %ld | a의 크기 : %ld | a의 주소값 : %p | a의 값 : %s", strlen(a), sizeof(a), &a, a);
printf("a[0]의 주소값 : %p | a[0]의 값 : %c\n", &a[0], a[0]);
printf("c의 길이 : %ld | c의 크기 : %ld | c의 주소값 : %p | c의 값 : %s", strlen(c), sizeof(c), &c, c);
printf("c[0]의 주소값 : %p | a[0]의 값 : %c\n", &c[0], c[0]);
```

출력값
```
a의 길이 : 17 | a의 크기 : 18 | a의 주소값 : 0x7ffffcf0ad60 | a의 값 : where is jontonde
a[0]의 주소값 : 0x7ffffcf0ad60 | a[0]의 값 : w
c의 길이 : 17 | c의 크기 : 8 | c의 주소값 : 0x7ffffcf0ad58 | c의 값 : where is jontonde
c[0]의 주소값 : 0x7ffffcf0ad60 | c[0]의 값 : w
```

우선 a부터 살펴보자.   
보다시피 배열 a는 a의 첫 원소의 주소값을 가지고 있다.

c에서 배열은 연속적인 메모리를 할당받기 때문에 w 후의 문자들은 각각 0x7ffffcf0ad61, 0x7ffffcf0ad62, 0x7ffffcf0ad63 ... 를 할당받게 된다.

그렇기 때문에 포인터 변수 또한 각 주소를 이동하며 배열처럼 활용할 수 있는 것이다.

---

그렇다면 가장 차이점은 무엇일까

```
a의 길이 : 17 | a의 크기 : 18 | a의 주소값 : 0x7ffffcf0ad60 | a의 값 : where is jontonde
c의 길이 : 17 | c의 크기 : 8 | c의 주소값 : 0x7ffffcf0ad58 | c의 값 : where is jontonde
```

이곳을 보면 차이점이 두 군데 보이는데 크기와 주소값이다.

분명 c = a로 초기화한 c는 a와 다른 주소값을 가지고 있다.   
c는 포인터로 'a의 첫 원소의 주소값을 가리키고 있는 포인터'가 저장되어 있는 메모리주소를 출력해주기 때문이다.

그렇다면 a도 첫 원소의 주소값을 가지고 있다고 했는데 어째서 따로 그것을 담아둔 주소가 없는 것일까?

이는 처음에 언급했듯이 배열이 자료형이기 때문이다.   
a의 값은 단순히 a[0]의 주소를 가지고 있는 포인터가 아니라, 배열이라는 자료형을 가지고 있기 때문이다.   
이 때문에 각 크기를 보면 a는 18이고, c는 8인데,

a는 char 자료형의 크기인 1바이트를 문자열을 종료하는 null문자까지 포함해 18바이트의 크기를 가진 배열이 되는 것이고,

c는 그저 그 배열의 첫 원소의 주소값을 가지고 있는 포인터로서 포인터 자료형의 크기인 8바이트만 차지하게 되는 것이다.

번외로 32비트 운영체제에서는 4바이트고 64비트 운영체제에서는 8바이트라고 한다 O_O!
