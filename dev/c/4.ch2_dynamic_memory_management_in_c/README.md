# 2장 Dynamic Memory Management in C

C 프로그램은 '런타임 환경'에서 작동한다!
런타임 환경에서는 스택, 힙을 활용하고 프로그램을 동작시킬 수 있다.  

일반적으로 우리가 변수를 선언하는 경우에는 런타임 시스템에서 자동으로 스택에 할당함.  
static 과 global 변수는 data segment에 할당되는데, 여긴 런타임 시스템이 만지는 곳 아님!  

C에서 힙의 메모리를 수동으로 할당하는 것을 ** 킹적 메모리 갓당 ** 이라고 부름 (해제까지 포함하면 '동적 메모리 관리')

```
QQ
'런타임 환경'이라는 것이 정확히 무엇인가?  
```

## 동적 메모리 할당

장문충을 극혐하는 이들을 위한 동적할당 3줄 요약  

1. malloc을 써서 메모리를 할당한다!!  
2. 할당받은 메모리를 사용한다!  
3. free로 할당받은 메모리를 해제한다!  

malloc == 인자 단 하나!에 할당할 바이트 수를 적으면 힙 메모리 할당해줌!  
안되면(똥컴새끼가 줄 메모리가 없다든가) null pointer를 반환함!  
이식성(사실 사이즈 다 기억 못해서)을 위해서 sizeof를 써주자!

free == malloc과 쌍으로 할당한 메모리를 해제하기 위해 사용함!  
해제된 메모리는 닷씨는 참조되어선 안됨.  

할당된 메모리 블럭 앞에는 그 블럭에 대한 정보가 따로 저장됨.  
여기엔 메모리 블럭의 크기 등 부가적인 정보가 담겨있으며, 힙 매니저에서 관리함.  
프로그램이 할당된 메모리 밖에 무언가를 작성하려 한다면 몬가.. 몬가 문제가 생길 수 있음.(ch7)  


### 메모리 누수

메모리의 주소를 잃어버렸을 때, 혹은 free를 사용하여 할당된 메모리를 해제하지 않았을 때 발생.  
메모리가 필요한데 줄 메모리가 없을 때 프로그램이 종료되거나 심한 경우엔 OS가 터질 수도 있음.

주소를 잃어버리는 경우는 malloc 후 free를 하지 않고 malloc으로 새로운 메모리를 할당하는 경우  
기존에 할당받은 메모리의 주소를 알 수가 없어서 누수가 발생한다.  

흔히 써왔던 방법 중에 주소값을 ++ 해서 문자열을 출력하는 방법이 있는데,  
이 방법도 문자열이 시작되는 주소값을 잃어버리게 되어 추후 문제가 발생할 수 있다.  

그 외에도 구조체를 사용할 때 구조체 안에 동적할당된 메모리를 가리키는 포인터를 가지고 있다면,  
그 포인터부터 free해주고 구조체를 free해줘야한다!

```
QQ
++ 한 주소값은 걍 -- 해서 돌아가면 되는데 이게 외않됌?
```

## 동적 메모리 할당 함수

- malloc : 힙에서 메모리 할당함. 할당할 바이트 수를 인자로 가짐.  
- realloc : 기존에 할당된 메모리를 기준으로 더 큰, 혹은 더 작은 메모리를 재할당함  
- calloc : 힙에서 메모리를 할당하고 다 0으로 채움.
- free : 할당된 메모리를 해제하여 어머니 힙의 품으로 되돌려줌  

### 공포의 malloc 아저씨

가장 작은(가장 앞에 있는) 바이트의 주소값이 반환됨. OS가 가난해서 메모리를 못 주면 NULL이 반환됨.  
malloc 자체적으로는 메모리를 할당만 하지 별 다른 조작은 가하지 않기에, 데이터를 만지기 전엔 모두 쓰레기값으로 가정.  
malloc이 0을 인자로 받을 시, 결과는 implementaion-specific하다.  
널 포인터를 반환할 수도 있고, 0바이트가 할당된 주소를 반환할 수도 있다.  
NULL을 인자로 받을 시, 보통 warning 뜨고 실행은 되는데, 0바이트를 반환한다.  
void pointer 덕분에 type casting을 안해도 되긴 하지만, 코드의 가독성과 호환성을 위해 사용하면 좋긴 하다!(하라는 뜻)  
malloc에서 크기를 지정할 때는 꼭 sizeof를 사용해주도록 하자!  
malloc이 할당할 수 있는 메모리의 최대 크기는 시스템별로 다르다!  
size\_t 때처럼 OS마다 다른 것도 맞지만, 현재 가용한 메모리의 양이나, 
'lazy initialization'(접근을 하면 그제서야 부랴부랴 할당하는 방식)을 사용하는 OS 등 다른 이유도 많다.  
킹치만 일반적으로 개발자가 이런 문제를 신경써야 할 일은 없긴 하다!  
static이나 global 변수를 초기화할 땐 함수를 호출할 수 읍다! 그래서 malloc 쓰면 compile time 에러 뜸 ㅠㅠ  
하지만 static 변수는 선언과 동시에 하지말고 따로 초기화 식을 적어서 할당해줄 수는 있다.  
global은 함수 밖에 선언되고 코드가 실행가능하려면 함수 안에 있어야하므로 global은 동적이지 못하게 된다.ㅠㅜㅠ  

### calloc 사용하기

calloc은 인자를 2개 받음. 원소의 숫자와 크기를 각각 받는다. 실패하면 malloc과 동일하게 NULL 반환.  
인자 중 하나라도 0이면 null pointer가 반환될 수 있다.  
calloc이 할당을 할 수 없게 되면 null pointer를 반환하고 전역 변수 errno는 ENOMEM(out of memory)로 바뀌는데,  
이것은 POSIX 에러코드라서 어떤 OS에서는 되지 않을 수도 있다.  
malloc을 사용해서 calloc과 같은 효과를 보려면 memset과 함께 이용하면 된다.  
```c
int *pi = malloc(5 * sizeof(int));
memset(pi, 0, 5 * sizeof(int));
```

calocc은 바이트를 전부 0으로 채우는 과정이 추가된 만큼 malloc보다 처리시간이 길어질 수 있다!  

```
QQ
POSIX는 무엇일까?
그리고 errno는 뭘하는 놈이길래 전역변수로 지정되어 있는지, ENOMEM이 정확히 어떤 뜻인지!  
calloc은 malloc에 비해 얼마나 더 느릴까?
```

### realocc 리얼록으루다가

리얼록도 2개의 인자를 받음. 다시 할당할 포인터와 다시 할당할 크기를 각각 받음.  
재할당받은 메모리가 기존보다 작을 경우는 남은 메모리가 힙으로 반환된다.  
반대로 클 경우엔 가능하다면 그 뒤에 바로 이어서 늘어나지만,  
불가능한 경우는 힙의 다른 빈 공간에 새로 만들어지며, 기존 메모리는 그 곳으로 복사된다.  
pointer 인자가 null이 아니고 size 인자가 0인 경우엔 그 포인터의 메모리는 해제된다.  
메모리를 할당하는데 실패했다면 기존 메모리는 유지되지만, null pointer가 반환되고 errno가 ENOMEM으로 설정된다.  

### alloca malloca

alloca(MS에서는 malloca)는 메모리를 스택단에 할당해준다. 함수가 return하게 되면 메모리는 자동으로 해제된다.  
만약 런타임 시스템이 스택기반이 아니라면 잘 안 될 수가 있다.  그래서 표준도 아니고 이식성?확장성? 생각하면 안쓰는게 좋음..  
그뤼고 메모리 알아서 해제되는데 malloc 쓴 게 아니니 free도 하면 안되고 여기서 사용한 메모리주소를 반환해도 안 된다!  

## 도비는 free예요

메모리를 해제하게 되면 힙으로 반환되어 다시 다른 곳에서 사용할 수 있게 된다.  
포인터는 여전히 그 메모리를 가리키고 있을지 모르겠지만, 쓰레기값이라고 생각하면 된다! 싫으면 free하지 말든가  
free 함수가 null pointer를 받게 되면 보통은 아무것도 안함. 
malloc 친구들 말고 다른 방식으로 메모리 할당을 받은 포인터를 받게 되면 free의 작동은 UB가 된다!  

항상 같은 레벨에서 할당과 해제를 하자! 함수 내에서 할당한 건 함수 내에서 해제하는 것을 잊지마!  

### 자유가 된 포인터에게 NULL 먹이기

메모리가 해제되어도 포인터는 문제가 될 수 있기에(UB) 포인터에 NULL을 주는 경우가 있음.  
댕글링 포인터 같은 걸 해결하려고 한 시도인데, 이딴거 할 시간에 문제가 발생하는 이유를 찾아서 해결하는 게 나음.  
게다가 상수포인터엔 초기화할 때 말곤 NULL을 넣을 수도 없다!!  

### 더블 free 더블 free

double free는 한 메모리 블럭을 두번 해제하려고 할 때 쓰는 용어이다.  
그런 경우엔 런타임 에러가 뜬다!  

```
QQ
책에서 더블프리 했을 때 런타임 에러가 뜬다해놓고 뭐 뒤에선 해제가 됐는지 안됐는지 알아보기 힘들어 한다고 해서 뭐가 맞는 소린지 모르겠음 ;
```

### 프로그램 종료와 함께 메모리 해제하기

프로그램의 자원을 관리하는 건 OS의 책임임. 메모리도 마찬가지.  
응용 프로그램이 종료될 때 메모리가 오염이 되어있든 말든 중요한게 아님. 사실 종료된 이유가 오염 때문일 수도 있고...  
그래서 종료 전엔 뭐 따로 free 할 필요가 없음  

물론 free하면 좋은 이유들도 있긴 하다.  
꼬박꼬박 free해두는 건 좋은 습관이라 걍 할 수도 있는거고,  
메모리 누수나 비슷한 문제 해결을 위한 도구를 사용할 때도 깔끔할테고,  
찐따OS에서는 메모리 관리 못해서 프로그램단에서 따로 해줘야할 수도 있다.  

정리하자면,  
- 득보다 실이 많을 수 있음  
- 시간도 더 들어가고 구조 복잡하면 어려울 수도 있음  
- 프로그램 크기 증가  
- 프로그램 실행 시간 증가  
- 오히려 오류가 증가할 수도 있음  
그래서 종료 전에 free 해주는 것은 프로그램에 따라 꼭 할 필욘 없으니 잘 고려해보자!  

## 덜렁덜렁거리는 포인터

dangling 포인터 == 해제된 후의 메모리를 여전히 가리키고 있는 pointer  

이것을 사용하게 되면 문제들이 발생할 수 있음 :  
- 해당 메모리에 접근했을 때 무슨 일이 일어날지 알 수 없음.  
- 접근이 불가능할 땐 세그폴트가 뜸
- 보안 문제 가능성  

언급한 문제들은 이런 경우 발생할 수 있음 :  
- 해제된 메모리에 접근
- 포인터가 과거에 호출된 함수에서 자동변수에게 반환된(뭐라는지 모름 ch3에 나옴)  

### 딜링 덜렁 포인터

- 해제 후 pointer에 NULL값 주기 : 하지만 포인터가 많으면 소용 없쥬?  
- free를 대체할 나만의 함수 만들기  
- 어떤 시스템은 메모리가 해제되면 특정 값을 알아서 집어넣음.  
뭐 결국 해결법은 아니지만 해당 값이 발견되면 아 덜렁거리는구나! 하고 알 수는 있다!  
- 외부 도구 사용 ㅎ  

## 동적 할당 기술

뭐 이것저것 있다는데 지금 다룰 문제인가?  








닌자 = argument
매개변수 = parameter


